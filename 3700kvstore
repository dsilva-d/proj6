#!/usr/bin/env python

import sys, socket, select, time, json, random

# Your ID number
my_id = sys.argv[1]

# The ID numbers of all the other replicas
replica_ids = sys.argv[2:]

# Connect to the network. All messages to/from other replicas and clients will
# occur over this socket
sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
sock.connect(my_id)

last = 0
cmode = "follower"
voteg = False
term = 0
ctimeout = 0 #50 ms: .05 - 0.1 random number
cvote = 0
leader = 'FFFF' # keep track of current leader
our_dict = {}

if my_id == '0000':
   cmode = "leader"
   leader = '0000'
else:
   cmode = "follower"
   leader = '0000'

def election():
   set_timeout()
   # sent out/recieved request vote
   

def set_timeout():
   ctimeout = random.randrange(0.05, 0.1)

while True:
   ready = select.select([sock], [], [], 0.1)[0]

   if sock in ready:
      msg_raw = sock.recv(32768)

      if len(msg_raw) == 0: continue
      msg = json.loads(msg_raw)
      # For now, ignore get() and put() from clients
      if cmode == "follower":
         if msg['type'] in ['get', 'put']:
            lead = 0
            pmsg = msg


            if pmsg['dst'] != pmsg['leader']:

               #rlead = 'FFFF' #real leader

               #cmode = "candidate"
               msg = {'src': my_id, 'dst': pmsg['src'], 'leader': leader, 'type': 'redirect', 'MID': pmsg['MID']}

               print 'REDIRECTING F'
            else:
               msg = {'src': my_id, 'dst': pmsg['src'], 'leader': 'leader', 'type': 'fail', 'MID': pmsg['MID']}
               print 'FAIL F'
               print(str(msg))

            print '%s received a GET/PUT from %s' % (msg['dst'], msg['src'])
            sock.send(json.dumps(msg))
            pass
         elif msg['type'] == 'rvote':
            if not voteg:
               # send a vote to the source
               term += 1
               voteg = True
               res_msg = {'src': my_id, 'dst': msg['src'], 'leader': leader, 'type': 'lvote', 'voted': True}
            else:
               res_msg = {'src': my_id, 'dts': msg['src'], 'leader': leader, 'type': 'lvote', 'voted': False}

                                # Handle noop messages. This may be removed from your final implementation
         elif msg['type'] == 'noop':
            print '%s received a NOOP from %s' % (msg['dst'], msg['src'])
      elif cmode == "candidate":
         if msg['type'] in ['get', 'put']:
            lead = 0
            pmsg = msg
            if pmsg['dst'] != pmsg['leader']:
               rlead = 'FFFF' #real leader
               cmode = "candidate"
               msg = {'src': my_id, 'dst': msg['dst'], 'leader': rlead, 'type': 'redirect'}
               print 'REDIRECTING C'
            else:
               msg = {'src': my_id, 'dst': random.choice(replica_ids), 'leader': 'FFFF', 'type': 'fail'}
               print 'FAIL C'
            print '%s received a GET/PUT from %s' % (msg['dst'], msg['src'])
            sock.send(json.dumps(msg))
            pass
                                # Handle noop messages. This may be removed from your final implementation
         elif msg['type'] == 'noop':
            print '%s received a NOOP from %s' % (msg['dst'], msg['src'])
         #elif msg['type'] == 'vote':
            # increment votes
      elif cmode == "leader":
         if msg['type'] in ['get', 'put']:
            #lead = 0
            pmsg = msg
            if pmsg['dst'] != pmsg['leader']:
               #rlead = 'FFFF' #real leader
               #cmode = "candidate"
               msg = {'src': my_id, 'dst': pmsg['src'], 'leader': leader, 'type': 'redirect', 'MID': pmsg['MID']}
               print 'REDIRECTING L'
            else:
               if msg['type'] == 'get':
                  try:
                     val = our_dict[pmsg['key']] # get the key value
                  except:
                     val = ''
                  #for pairs in data:
                  #   if pairs['key'] == pmsg['key']:
                  #      val = pairs['value']
                  #      break
                  #if val == NULL:i
                  #   msg = {'src': my_id, 'dst': pmsg['src'], 'leader': leader, 'type': 'fail', 'MID': pmsg['MID']} # was originally a fail type
                  #else:
                  msg = {'src': my_id, 'dst': pmsg['src'], 'leader': leader, 'type': 'ok', 'MID': pmsg['MID'], 'value': val} # was originally a fail type
               else:
                  # place the key value pair
                  #our_dict = {'key': pmsg['key'], 'value': pmsg['value']}
                  #data.append(our_dict)

                  our_dict[pmsg['key']] = pmsg['value']

                  msg = {'src': my_id, 'dst': pmsg['src'], 'leader': leader, 'type': 'ok', 'MID': pmsg['MID']} # was originally a fail type

               #msg = {'src': my_id, 'dst': pmsg['src'], 'leader': leader, 'type': 'ok', 'MID': pmsg['MID'], 'value': '0'} # was originally a fail type
               #print 'FAIL'
               print(str(msg))
            print '%s received a GET/PUT from %s in Leader' % (msg['dst'], msg['src'])
            sock.send(json.dumps(msg))
            pass
         elif msg['type'] == 'rvote':
            res_msg = {'src': my_id, 'dts': msg['src'], 'leader': leader, 'type': 'lvote', 'voted': False}
         elif msg['type'] == 'lvote':
             if msg['voted'] == True:
                cvote += 1
                                # Handle noop messages. This may be removed from your final implementation
         elif msg['type'] == 'noop':
            print '%s received a NOOP from %s' % (msg['dst'], msg['src'])
   clock = time.time()
   if clock-last > 0.03 and my_id == leader:
      for replica in replica_ids:
         msg = {'src': my_id, 'dst': replica, 'leader': leader, 'type': 'appendEntries'}
         sock.send(json.dumps(msg))
         last = clock
if clock-last > 2:
   # Send a no-op message to a random peer every two seconds, just for fun
   # You definitely want to remove this from your implementation
   msg = {'src': my_id, 'dst': random.choice(replica_ids), 'leader': 'FFFF', 'type': 'noop'}
   sock.send(json.dumps(msg))
   print '%s sending a NOOP to %s' % (msg['src'], msg['dst'])
   last = clock
