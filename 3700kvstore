#!/usr/bin/env python

import sys, socket, select, time, json, random

# Your ID number
my_id = sys.argv[1]

# The ID numbers of all the other replicas
replica_ids = sys.argv[2:]

# Connect to the network. All messages to/from other replicas and clients will
# occur over this socket
sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
sock.connect(my_id)

last = 0
cmode = "follower"
voteg = False
term = 0

ctimeout = random.randrange(100, 200)
ctimeout = ctimeout * 0.005 

cvote = 0
leader = 'FFFF' # keep track of current leader
our_dict = {}
heart = 0
getq = []
putq = []
dent = []

if my_id == '0000':
   cmode = "leader"
   leader = '0000'
else:
   cmode = "follower"
   leader = '0000'

def election():
   set_timeout()
   # sent out/recieved request vote
   

def set_timeout():
   ctimeout = random.randrange(100, 200)
   ctimeout = ctimeout * 0.005
   print ctimeout




while True:
   ready = select.select([sock], [], [], 0.1)[0]

   if sock in ready:
      msg_raw = sock.recv(32768)
      
      if len(msg_raw) == 0: continue
      msg = json.loads(msg_raw)
      #print str(msg)
      #In election
      if leader == 'FFFF':
         print "IN ELECTION: " + str(my_id)
        

         
         pmsg = msg
         if cmode == "follower":
            if msg['type'] in ['get', 'put']:
               if msg['type'] == 'put':
                  our_dict[pmsg['key']] = pmsg['value']
              
               res_msg = {'src': my_id, 'dst': pmsg['src'], 'leader': leader, 'type': 'fail', 'term': term, 'MID': pmsg['MID']}
            
            elif msg['type'] == 'rvote' and term < msg['term']:
               print "Requesting vote to follower: " + str(msg['src']) + " to " + str(my_id)
               term = pmsg['term']
               last = clock
               res_msg = {'src': my_id, 'dst': pmsg['src'], 'leader': leader, 'type': 'lvote', 'term': term, 'voted': False}
            sock.send(json.dumps(res_msg)) #moved
            #continue

 
         if cmode == 'candidate':
            print 'CANDIDATE: ' + my_id + ', ' + str(cvote)
            if msg['type'] in ['get', 'put']:
               res_msg = {'src': my_id, 'dst': pmsg['src'], 'leader': leader, 'type': 'fail', 'term': term, 'MID': pmsg['MID']}
       
               sock.send(json.dumps(res_msg))
            #request vote
            elif msg['type'] == 'rvote':
               print 'myid: ' + str(my_id)
               print str(msg)
               print "Requesting vote to candidate: " + str(msg['src']) + " to " + str(my_id)
               res_msg = {'src': my_id, 'dst': msg['src'], 'leader': leader, 'type': 'lvote', 'term': term, 'voted': False}
               if msg['term'] > term:
                  cmode = 'follower'
                  term = msg['term']
                  res_msg = {'src': my_id, 'dst': msg['src'], 'leader': leader, 'type': 'lvote', 'term': term, 'voted': True}
               
               sock.send(json.dumps(res_msg))
            #ack vote
            elif msg['type'] == 'lvote':
               if msg['voted']:
                  cvote += 1
                

            #have majority voted
            if cvote >= len(replica_ids) / 2:
               leader = my_id
               cmode = 'leader'
               print '\n\n\n\n\nELECTION IS OVER: ' + str(leader) + '\n\n\n\n'
               for replica in replica_ids:
                  if my_id != replica:
                     msg = {'src': my_id, 'dst': replica, 'term': term, 'leader': leader, 'type': 'appendEntries'}
                     sock.send(json.dumps(msg))


               last = time.time()
               

         if pmsg['type'] == 'appendEntries':
            if pmsg['term'] >= term:
               leader = pmsg['src']
               print 'APPEND LEADER: ' + leader
               term = pmsg['term']

               msg = {'src': my_id, 'dst': leader, 'leader': leader, 'term': term, 'log': dent, 'type': 'appResponse'}
               sock.send(json.dumps(msg))
               cmode = 'follower'
#ELECTION TIME OUT - RESET
         clock = time.time()            
         if clock - last >= ctimeout:
            cmode = 'candidate'
            term += 1
            print 'TIMEOUT, ELECTION RESTART, TERM: ' + str(term)

            set_timeout()
            for replica in replica_ids:
               print 'my_id: ' + str(my_id)
               print 'replica: ' + str(replica)
               if my_id != replica:
                  msg = {'src': my_id, 'dst': replica, 'leader': leader, 'term': term, 'type': 'rvote'}
                  
                  sock.send(json.dumps(msg))

 

         last = time.time()
         continue   
      
      
      # For now, ignore get() and put() from clients
      if cmode == "follower":
         if msg['type'] in ['get', 'put']:
            pmsg = msg
            if pmsg['dst'] != pmsg['leader']:
               
               #cmode = "candidate"
               msg = {'src': my_id, 'dst': pmsg['src'], 'leader': leader, 'type': 'redirect', 'MID': pmsg['MID']}
               print 'REDIRECTING FOLLOWER: ' + str(my_id)
               print 'CURRENT LEADER: ' + leader
               print 'CURRENT TERM: ' + str(term)

            else:
               
               msg = {'src': my_id, 'dst': pmsg['src'], 'leader': leader, 'type': 'fail', 'term': term, 'MID': pmsg['MID']}
               print(str(msg))

            print '%s received a GET/PUT from %s' % (msg['dst'], msg['src'])
            sock.send(json.dumps(msg))
            pass
         if msg['type'] == 'rvote':
            print str(my_id) + ' received an unapproved request vote!'
            last = time.time()
            if not voteg and msg['term'] > term:
               leader = 'FFFF'
               print str(my_id) + ' received a request vote!'
               # send a vote to the source
               
               term = msg['term']
               
               voteg = True
               res_msg = {'src': my_id, 'dst': msg['src'], 'leader': leader, 'type': 'lvote', 'term': term, 'voted': True}
            else:
               res_msg = {'src': my_id, 'dst': msg['src'], 'leader': leader, 'type': 'lvote', 'term': term, 'voted': False}
            sock.send(json.dumps(res_msg))
                                # Handle noop messages. This may be removed from your final implementation

         clock = time.time()
         if msg['type'] == 'appendEntries' and msg['term'] >= term:
            #record start of heartbeat
            print 'RESET HEARTBEAT OF ' + str(my_id)
            last = clock
            if msg['term'] > term:
               term = msg['term']
            res_msg = {'src': my_id, 'dst': leader, 'leader': leader, 'term': term, 'log': dent, 'type': 'appResponse'}
            sock.send(json.dumps(res_msg))
            

          



         if clock - last > ctimeout:
            print '\n\n\n\nclock-last:' + str(clock - last) + '\n\n\n\n'
            #start election
            leader = 'FFFF'
            print 'ELECTION STARTED BY: ' + str(my_id)

            term += 1
            print '\nTERM INCREMENTED: ' + str(term) + '\n'

            cmode = 'candidate'
            set_timeout()
            last = clock
            for replica in replica_ids:
               print 'my_id: ' + str(my_id)
               print 'replica: ' + str(replica)
               if my_id != replica:
                  msg = {'src': my_id, 'dst': replica, 'leader': leader, 'term': term, 'type': 'rvote'}
               
                  sock.send(json.dumps(msg))

         elif msg['type'] == 'noop':
            print '%s received a NOOP from %s' % (msg['dst'], msg['src'])
                                # Handle noop messages. This may be removed from your final implementation
            # increment votes
      elif cmode == "leader":
         print 'LEADER IS UP: ' + str(my_id)
         if msg['type'] in ['get', 'put']:
            pmsg = msg
            if pmsg['dst'] != pmsg['leader']:
               #rlead = 'FFFF' #real leader
               msg = {'src': my_id, 'dst': pmsg['src'], 'leader': leader, 'type': 'redirect', 'term': term, 'MID': pmsg['MID']}
               print 'REDIRECTING L'
            else:
               if msg['type'] == 'get':
                  try:
                     val = our_dict[pmsg['key']] # get the key value
                  except:
                     val = ''
                  msg = {'src': my_id, 'dst': pmsg['src'], 'leader': leader, 'type': 'ok', 'term': term, 'MID': pmsg['MID'], 'value': val} # was originally a fail type
               elif msg['type'] == 'put':
                  our_dict[pmsg['key']] = pmsg['value']
                  msg = {'src': my_id, 'dst': pmsg['src'], 'leader': leader, 'type': 'ok', 'term': term, 'MID': pmsg['MID']}


             #sending logs 
            #for replica in replica_ids:
            #   if my_id != replica:
            #      msg = {'src': my_id, 'dst': replica, 'leader': leader, 'term': term, 'log': msg, 'type': 'appendEntries'}
            #      sock.send(json.dumps(msg))
   
 
 
               #LEADER RECIEVES REQUEST VOTE
               elif msg['type'] == 'rvote':
                  cmode == 'follower'
                  last = time.time()
                  if not voteg:
                     leader = 'FFFF'
                     print str(my_id) + ' received a request vote!'
                     # send a vote to the source
                     term = msg['term']
                     voteg = True
                     res_msg = {'src': my_id, 'dst': msg['src'], 'leader': leader, 'type': 'lvote', 'term': term, 'voted': True}
                  else:
                     res_msg = {'src': my_id, 'dst': msg['src'], 'leader': leader, 'type': 'lvote', 'term': term, 'voted': False}

               #print(str(msg))
            print '%s received a GET/PUT from %s in Leader' % (msg['dst'], msg['src'])
            sock.send(json.dumps(msg))
            pass
                                # Handle noop messages. This may be removed from your final implementation
         elif msg['type'] == 'appendEntries':
            if msg['term'] >= term:
               cmode = 'follower'
               leader = msg['src']

         #elif msg['type'] == 'appResponse':
         #   dent.append(msg['log'])
   
         elif msg['type'] == 'noop':
            print '%s received a NOOP from %s' % (msg['dst'], msg['src'])
   clock = time.time()
   if clock-last > 0.03 and my_id == leader:
      last = clock
      for replica in replica_ids:
         if my_id != replica:
            msg = {'src': my_id, 'dst': replica, 'leader': leader, 'term': term, 'type': 'appendEntries'}
            sock.send(json.dumps(msg)) 
   


if clock-last > 2:
   # Send a no-op message to a random peer every two seconds, just for fun
   # You definitely want to remove this from your implementation
   msg = {'src': my_id, 'dst': random.choice(replica_ids), 'leader': 'FFFF', 'term': term, 'type': 'noop'}
   sock.send(json.dumps(msg))
   print '%s sending a NOOP to %s' % (msg['src'], msg['dst'])
   last = clock
