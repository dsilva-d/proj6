#!/usr/bin/env python

import sys, socket, select, time, json, random

# Your ID number
my_id = sys.argv[1]

# The ID numbers of all the other replicas
replica_ids = sys.argv[2:]

# Connect to the network. All messages to/from other replicas and clients will
# occur over this socket
sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
sock.connect(my_id)

last = 0
cmode = "follower"
voteg = False
term = 0
ctimeout = 0 #50 ms: .05 - 0.1 random number
cvote = 0
leader = 'FFFF' # keep track of current leader
our_dict = {}
heart = 0

if my_id == '0000':
   cmode = "leader"
   leader = '0000'
else:
   cmode = "follower"
   leader = '0000'

def election():
   set_timeout()
   # sent out/recieved request vote
   

def set_timeout():
   ctimeout = random.randrange(1, 2)
   ctimeout *= 0.05


set_timeout()

while True:
   ready = select.select([sock], [], [], 0.1)[0]

   if sock in ready:
      msg_raw = sock.recv(32768)

      
      #In election
      if leader == 'FFFF':
         print "IN ELECTION"
         pmsg = msg
         if cmode == "follower":
            if msg['type'] in ['get', 'put']:
               if msg['type'] == 'get':
                  try:
                     val = our_dict[pmsg['key']] # get the key value
                  except:
                     val = ''
               else:
                  our_dict[pmsg['key']] = pmsg['value']
               msg = {'src': my_id, 'dst': pmsg['src'], 'leader': leader, 'type': 'fail', 'MID': pmsg['MID']}
            elif msg['type'] == 'rvote':
               res_msg = {'src': my_id, 'dts': msg['src'], 'leader': leader, 'type': 'lvote', 'voted': False}
            
 
         if cmode == 'candidate':
            #request vote
            if msg['type'] == 'rvote':
               res_msg = {'src': my_id, 'dts': msg['src'], 'leader': leader, 'type': 'lvote', 'voted': False}
            #ack vote
            elif msg['type'] == 'lvote':
               if msg['voted']:
                  cvote += 1

            #have majority voted
            if cvote >= len(replica_ids) + 1 / 2:
               leader = my_id
               cmode = 'leader'
               for replica in replica_ids:
                  msg = {'src': my_id, 'dst': replica, 'leader': leader, 'type': 'appendEntries'}
                  sock.send(json.dumps(msg))
               last = time.time()
         if pmsg['type'] == 'appendEntries':
            leader = pmsg['src']
            msg = {'src': my_id, 'dst': leader, 'leader': leader, 'type': 'appResponse'}
            sock.send(json.dumps(msg))
         last = time.time()
         
      
      if len(msg_raw) == 0: continue
      msg = json.loads(msg_raw)
      # For now, ignore get() and put() from clients
      if cmode == "follower":
         if msg['type'] in ['get', 'put']:
            lead = 0
            pmsg = msg
            if pmsg['dst'] != pmsg['leader']:

               #rlead = 'FFFF' #real leader

               #cmode = "candidate"
               msg = {'src': my_id, 'dst': pmsg['src'], 'leader': leader, 'type': 'redirect', 'MID': pmsg['MID']}

               print 'REDIRECTING F'
            else:
               msg = {'src': my_id, 'dst': pmsg['src'], 'leader': 'leader', 'type': 'fail', 'MID': pmsg['MID']}
               print 'FAIL F'
               print(str(msg))

            print '%s received a GET/PUT from %s' % (msg['dst'], msg['src'])
            sock.send(json.dumps(msg))
            pass
         if msg['type'] == 'rvote':
            if not voteg:
               leader = 'FFFF'
               print str(my_id) + ' received a request vote!'
               # send a vote to the source
               term += 1
               voteg = True
               res_msg = {'src': my_id, 'dst': msg['src'], 'leader': leader, 'type': 'lvote', 'voted': True}
            else:
               res_msg = {'src': my_id, 'dts': msg['src'], 'leader': leader, 'type': 'lvote', 'voted': False}
                                # Handle noop messages. This may be removed from your final implementation
         clock = time.time()
         if msg['type'] == 'appendEntries':
            #record start of heartbeat
            print 'RESET HEARTBEAT OF ' + str(my_id)
            last = clock
         if clock - last > ctimeout:
            #start election
            leader = 'FFFF'
            cmode = 'candidate'
            set_timeout()

         elif msg['type'] == 'noop':
            print '%s received a NOOP from %s' % (msg['dst'], msg['src'])
      #elif cmode == "candidate":
         #if msg['type'] in ['get', 'put']:
         #   lead = 0
         #   pmsg = msg
         #   if pmsg['dst'] != pmsg['leader']:
         #      msg = {'src': my_id, 'dst': msg['dst'], 'leader': rlead, 'type': 'redirect'}
         #      print 'REDIRECTING C'
         #   else:
         #      msg = {'src': my_id, 'dst': random.choice(replica_ids), 'leader': 'FFFF', 'type': 'fail'}
         #      print 'FAIL C'
         #   print '%s received a GET/PUT from %s' % (msg['dst'], msg['src'])
         #   sock.send(json.dumps(msg))
         #   pass
                                # Handle noop messages. This may be removed from your final implementation
         #elif msg['type'] == 'noop':
      #   if msg['type'] == 'noop':
      #      print '%s received a NOOP from %s' % (msg['dst'], msg['src'])
            # increment votes
      elif cmode == "leader":
         if msg['type'] in ['get', 'put']:
            #lead = 0
            print "LEADER IS " + str(my_id)
            pmsg = msg
            if pmsg['dst'] != pmsg['leader']:
               #rlead = 'FFFF' #real leader
               msg = {'src': my_id, 'dst': pmsg['src'], 'leader': leader, 'type': 'redirect', 'MID': pmsg['MID']}
               print 'REDIRECTING L'
            else:
               if msg['type'] == 'get':
                  try:
                     val = our_dict[pmsg['key']] # get the key value
                  except:
                     val = ''
                  #for pairs in data:
                  #   if pairs['key'] == pmsg['key']:
                  #      val = pairs['value']
                  #      break
                  #if val == NULL:i
                  #   msg = {'src': my_id, 'dst': pmsg['src'], 'leader': leader, 'type': 'fail', 'MID': pmsg['MID']} # was originally a fail type
                  #else:
                  msg = {'src': my_id, 'dst': pmsg['src'], 'leader': leader, 'type': 'ok', 'MID': pmsg['MID'], 'value': val} # was originally a fail type
               else:
                  # place the key value pair
                  #our_dict = {'key': pmsg['key'], 'value': pmsg['value']}
                  #data.append(our_dict)

                  our_dict[pmsg['key']] = pmsg['value']

                  msg = {'src': my_id, 'dst': pmsg['src'], 'leader': leader, 'type': 'ok', 'MID': pmsg['MID']} # was originally a fail type

               #msg = {'src': my_id, 'dst': pmsg['src'], 'leader': leader, 'type': 'ok', 'MID': pmsg['MID'], 'value': '0'} # was originally a fail type
               #print 'FAIL'
               print(str(msg))
            print '%s received a GET/PUT from %s in Leader' % (msg['dst'], msg['src'])
            sock.send(json.dumps(msg))
            pass
         elif msg['type'] == 'rvote':
            res_msg = {'src': my_id, 'dts': msg['src'], 'leader': leader, 'type': 'lvote', 'voted': False}
         elif msg['type'] == 'lvote':
             if msg['voted'] == True:
                cvote += 1
                                # Handle noop messages. This may be removed from your final implementation
         elif msg['type'] == 'noop':
            print '%s received a NOOP from %s' % (msg['dst'], msg['src'])
   clock = time.time()
   if clock-last > 0.03 and my_id == leader:
      for replica in replica_ids:
         msg = {'src': my_id, 'dst': replica, 'leader': leader, 'type': 'appendEntries'}
         sock.send(json.dumps(msg))
         
   last = clock
   


if clock-last > 2:
   # Send a no-op message to a random peer every two seconds, just for fun
   # You definitely want to remove this from your implementation
   msg = {'src': my_id, 'dst': random.choice(replica_ids), 'leader': 'FFFF', 'type': 'noop'}
   sock.send(json.dumps(msg))
   print '%s sending a NOOP to %s' % (msg['src'], msg['dst'])
   last = clock

