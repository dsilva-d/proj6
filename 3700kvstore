#!/usr/bin/env python

import sys, socket, select, time, json, random

# Your ID number
my_id = sys.argv[1]

# The ID numbers of all the other replicas
replica_ids = sys.argv[2:]

# Connect to the network. All messages to/from other replicas and clients will
# occur over this socket
sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
sock.connect(my_id)

last = 0
cmode = 'follower'
voteg = False
term = 0

ctimeout = random.randrange(100, 400)
ctimeout = ctimeout * 0.006 

cvote = 0
leader = 'FFFF' # keep track of current leader
our_dict = {}
heart = 0
getq = []
putq = []
dent = [] #logs
uncoment = {} #uncommited logs


#if my_id == '0000':
#   cmode = "leader"
#   leader = '0000'
#else:
#   cmode = "follower"
#   leader = '0000'
   

def set_timeout():
   ctimeout = random.randrange(100, 400)
   ctimeout = ctimeout * 0.006
   #print ctimeout




while True:
   ready = select.select([sock], [], [], 0.1)[0]

   if sock in ready:
      msg_raw = sock.recv(32768)
      
      if len(msg_raw) == 0: continue
      msg = json.loads(msg_raw)



      ########## ELECTION ##########

      if leader == 'FFFF':

         # Get/Put during election
         if msg['type'] in ['get', 'put']:
            #### DO NOTHING ####
            if msg['type'] == 'get':
               getq.append(msg)
               #print 'GETQ: ' + str(getq)
            else:
               putq.append(msg)
               #print 'PUTQ: ' + str(putq)
            #res_msg = {'src': my_id, 'dst': msg['src'], 'leader': leader, 'type': 'fail', 'MID': msg['MID']}
            #sock.send(json.dumps(res_msg))

         # Request Votes for runoff
         elif msg['type'] == 'rvote': 
            last = time.time()
            # Vote in runoff if haven't yet
            if term < msg['term'] and msg['loglen'] >= len(our_dict):
               cvote = 0
               cmode = 'follower'
               term = msg['term']
               print 'Voting true ' + my_id + ' for ' + msg['src']
               res_msg = {'src': my_id, 'dst': msg['src'], 'leader': leader, 'type': 'lvote', 'term': term, 'voted': True}
               sock.send(json.dumps(res_msg))
               last = time.time()
            # Has already voted in runoff
            else:
               print 'Voting false ' + my_id
               res_msg = {'src': my_id, 'dst': msg['src'], 'leader': leader, 'type': 'lvote', 'term': term, 'voted': False}
               sock.send(json.dumps(res_msg))
               last = time.time()
         # Append Entries ending election
         elif msg['type'] == 'appendEntries' and msg['term'] >= term:
            last = time.time()
            cmode = 'follower'
            term = msg['term']
            leader = msg['src']
            print 'Ending an election'
            ### Handle during elections?? ###
            print 'Putq: ' + str(putq)
            print 'Getq: ' + str(getq)
            res_msg = {'src': my_id, 'dst': leader, 'leader' : leader, 'type': 'appResponse', 'term': term, 'puts': putq, 'gets': getq}
            sock.send(json.dumps(res_msg))
            putq = []
            getq = []
            ################################

         # Candidate only
         elif cmode == 'candidate': 
            #print 'In candidate in election'
            # Recieving votes
            if msg['type'] == 'lvote':
               last = time.time()
               print 'Recieving votes'
               if msg['term'] > term:
                  cmode = 'follower'
                  continue
               else:
                  last = time.time()
               # Positive vote
                  if msg['voted']:
                     cvote += 1
            # Check if enough votes
            if cvote >= (len(replica_ids) + 1) / 2:
               print 'Enough votes'
               leader = my_id
               cvote = 0
               cmode = 'leader'
               last = time.time()
               for replica in replica_ids:
                  if my_id != replica:
                     res_msg = {'src': my_id, 'dst': replica, 'term': term, 'leader': leader, 'type': 'appendEntries', 'log': dent}
                     sock.send(json.dumps(res_msg))
               continue
               
         # Check for timeout
         clock = time.time()
         if clock-last >= ctimeout:
            print cvote
            print 'Calling new election: ' + my_id + ' with term ' + str(term+1)
            cmode = 'candidate'
            cvote = 1
            term += 1
            set_timeout()
            leader = 'FFFF'
            last = time.time()
            for replica in replica_ids:
                  if my_id != replica:
                     res_msg = {'src': my_id, 'dst': replica, 'term': term, 'leader': leader, 'loglen': len(our_dict), 'type': 'rvote'}
                     sock.send(json.dumps(res_msg))

         continue   


      ########## END ELECTION ##########


      if cmode == 'follower':
         if msg['type'] in ['get', 'put']:
            res_msg = {'src': my_id, 'dst': msg['src'], 'leader': leader, 'type': 'redirect', 'MID': msg['MID']}
            sock.send(json.dumps(res_msg))

         elif msg['type'] == 'rvote':
            leader = 'FFFF'
            cvote = 0
            last = time.time()
            if msg['term'] > term and msg['loglen'] >= len(our_dict):
               term = msg['term']
               res_msg = {'src': my_id, 'dst': msg['src'], 'leader': leader, 'type': 'lvote', 'term': term, 'voted': True}
               sock.send(json.dumps(res_msg))
            else:
               res_msg = {'src': my_id, 'dst': msg['src'], 'leader': leader, 'type': 'lvote', 'term': term, 'voted': False}
               sock.send(json.dumps(res_msg))

         elif msg['type'] == 'appendEntries' and msg['term'] >= term:
            term = msg['term']
            last = time.time()
            try:
               our_dict.update(msg['log'])
               #print 'LEADER: ' + leader
               #print 'MY ID: ' + my_id
               #print 'updated dictionary'
            except:
               pass
         elif msg['type'] == 'commit':
            res_msg = {'src': my_id, 'dst': msg['src'], 'osrc': msg['osrc'], 'leader': msg['src'], 'type': 'okcommit', 'MID': msg['MID'], 'value': msg['value'], 'key': msg['key']}
            sock.send(json.dumps(res_msg))

         clock = time.time()
         if clock-last >= ctimeout:
            print 'NEED TO ELECT A LEADER ' + my_id
            leader = 'FFFF'
            term += 1
            cvote = 1
            cmode = 'candidate'
            set_timeout()
            last = time.time()
            for replica in replica_ids:
               if my_id != replica:
                  res_msg = {'src': my_id, 'dst': replica, 'leader': leader, 'term': term, 'loglen': len(our_dict), 'type': 'rvote'}
                  sock.send(json.dumps(res_msg))


      elif cmode == 'leader':
         if msg['type'] in ['get', 'put']:
            if msg['dst'] != msg['leader']: ## Just added
               res_msg = {'src': my_id, 'dst': msg['src'], 'leader': leader, 'type': 'redirect', 'MID': msg['MID']} ## Just added
               sock.send(json.dumps(res_msg))
            elif msg['type'] == 'get':
               try:
                  val = our_dict[msg['key']]
               except:
                  val = ''
               
               res_msg = {'src': my_id, 'dst': msg['src'], 'leader': leader, 'type': 'ok', 'MID': msg['MID'], 'value': val}
               

               sock.send(json.dumps(res_msg))
            else:
               #res_msg = {'src': my_id, 'dst': msg['src'], 'leader': leader, 'type': 'commit', 'MID': msg['MID'], 'value': msg['value'], 'key': msg['key']}

               uncoment[msg['MID']] = [0, time.time(), msg]
               

               #res_msg = {'src': my_id, 'dst': msg['src'], 'leader': leader, 'type': 'ok', 'MID': msg['MID']}
               #sock.send(json.dumps(res_msg))
               #temp_dict = {}
               #temp_dict[msg['key']] = msg['value']

               for replica in replica_ids:
                  if my_id != replica:
                     res_msg = {'src': my_id, 'dst': replica, 'osrc': msg['src'], 'leader': leader, 'type': 'commit', 'MID': msg['MID'], 'value': msg['value'], 'key': msg['key']}
                     #res_msg = {'src': my_id, 'dst': replica, 'leader': leader, 'term': term, 'type': 'appendEntries', 'log': temp_dict}
                     sock.send(json.dumps(res_msg))

         ### Very unsure of this part ### 
         elif msg['type'] == 'appResponse':
            print 'In appResponse'
            to_put = msg['puts']
            to_get = msg['gets']
            print 'To Put: ' + str(to_put)
            print 'To Get: ' + str(to_get)
            print 'App Putq: ' + str(putq)
            print 'App Getq: ' + str(getq)
            #to_put = msg['puts']
            #to_get = msg['gets']
            for p in to_put:
               sock.send(json.dumps(p))
            for p in putq:
               sock.send(json.dumps(p))
            for g in to_get:
               sock.send(json.dumps(g))
            for g in getq:
               sock.send(json.dumps(g))
            putq = []
            getq = []
         ################################

         elif msg['type'] == 'rvote':
            if msg['term'] > term and msg['loglen'] >= len(our_dict):
               cmode = 'follower'
               last = time.time()
               leader = 'FFFF'
               term = msg['term'] 
               res_msg = {'src': my_id, 'dst': msg['src'], 'leader': leader, 'type': 'lvote', 'term': term, 'voted': True}
               sock.send(json.dumps(res_msg))
            else: 
               res_msg = {'src': my_id, 'dst': msg['src'], 'leader': leader, 'type': 'lvote', 'term': term, 'voted': False}
               sock.send(json.dumps(res_msg))
         elif msg['type'] == 'appendEntries' and msg['term'] >= term:
            term = msg['term']
            cmode = 'follower'
            leader = msg['src']
            continue
         elif msg['type'] == 'okcommit':
            #uncoment[msg['MID']][0] += 1
            #uncoment[msg['MID']][1] = time.time(i)
         
            #tempmid = uncoment[msg['MID']]
            try:
               tempnum = uncoment[msg['MID']][0] + 1
               tempmsg = uncoment[msg['MID']][2]

               #print 'Uncoment: ' + str(tempnum)           
 
               uncoment[msg['MID']] = [tempnum, time.time(), tempmsg]
            
                
               if uncoment[msg['MID']][0] == len(replica_ids) / 2:
                  #remove from uncommited
                  del uncoment[msg['MID']]

                  our_dict[msg['key']] = msg['value']
            
                  res_msg = {'src': my_id, 'dst': msg['osrc'], 'leader': leader, 'type': 'ok', 'MID': msg['MID'], 'value': msg['value']}
                  sock.send(json.dumps(res_msg))

                  temp_dict = {}
                  temp_dict[msg['key']] = msg['value']
                  for replica in replica_ids:
                     if my_id != replica:
                        res_msg = {'src': my_id, 'dst': replica, 'leader': leader, 'term': term, 'type': 'appendEntries', 'log': temp_dict}
                        sock.send(json.dumps(res_msg))
            except:
               pass
   
         tempcom = []
         for com in uncoment:
            if time.time() - uncoment[com][1] >= 3:

               print 'COMMIT TIME: ' + str(uncoment[com][1])
               print 'CURRENT TIME: ' + str(time.time())
               res_msg = {'src': my_id, 'dst': uncoment[com][2]['src'], 'leader': leader, 'type': 'fail', 'MID': uncoment[com][2]['MID']}
               sock.send(json.dumps(res_msg))
               tempcom.append(com)

         
         
         for com in tempcom:
            del uncoment[com]


         
         clock = time.time()
         if clock-last > 0.03:
            last = clock
            for replica in replica_ids:
               if my_id != replica:
                  res_msg = {'src': my_id, 'dst': replica, 'leader': leader, 'term': term, 'type': 'appendEntries', 'log': None} #time out should reset log?
                  sock.send(json.dumps(res_msg))

         for p in putq:
            sock.send(json.dumps(p))
         for g in getq:
            sock.send(json.dumps(g))
         putq = []
         getq = []
      else:
         print 'HUH???'
